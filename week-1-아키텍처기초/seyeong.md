# 클린 아키텍처 1~3장 정리

> 📖 = 책 내용 | 💭 = 개인 생각

## 📋 목차

- [서문](#서문)
- [1부: 소개](#1부-소개)
  - [1장: 설계와 아키텍처란?](#1장-설계와-아키텍처란)
  - [2장: 두 가지 가치에 대한 이야기](#2장-두-가지-가치에-대한-이야기)
- [2부: 벽돌부터 시작하기: 프로그래밍 패러다임](#2부-벽돌부터-시작하기-프로그래밍-패러다임)
  - [3장: 패러다임 개요](#3장-패러다임-개요)
- [정리 및 다음 학습 방향](#-정리-및-다음-학습-방향)

---

## 서문

📖 **아키텍처의 규칙은 동일하다**

- 소프트웨어는 과거와 동일한 것들로 구성된다: if문, 할당문, while 루프
- 소프트웨어 아키텍처의 규칙이 일관되었다

💭 **개인적인 공감**

- 정말 프로그래밍은 순차, 분기, 반복의 집합체
- 이전 회사 신입에게 "if, for문, 함수만 알면 문제없다"고 말했던 것이 생각남
  - jQuery 기반 환경이었어서 실제로 if, for문만 잘 써도 대부분 해결 가능했음
- 계속해서 오답을 거쳐오며 그 오답을 통해 규칙을 깨닫게 되었으늬 정답을 알려준다는 말 같아서 설렘. 정답지 훔쳐보는 느낌으로 읽어봐야겠다.

---

# 1부: 소개

## 1장: 설계와 아키텍처란?

### 📖 소프트웨어 개발의 현실

**프로그램 동작의 용이성**

- 프로그램이 동작하게 만드는 데는 엄청난 수준의 지식과 기술이 필요하지 않다
- 하지만 "제대로" 만드는 것은 다른 문제

**설계 vs 아키텍처**

- 설계와 아키텍처는 아무런 차이가 없다
- "아키텍처": 고수준의 무언가
- "설계": 저수준의 구조 또는 결정사항
- 고수준에서 저수준으로 향하는 의사결정의 연속성만 있을 뿐

### 📖 소프트웨어 아키텍처의 목표

```
소프트웨어 아키텍처의 목표 = 필요한 시스템을 만들고 유지보수하는데 투입되는 인력을 "최소화"
```

**좋은 설계 vs 나쁜 설계**

- 좋은 설계: 고객의 요구를 만족시키는 시스템을 만들고, 시스템의 수명이 다할 때까지 낮은 유지비용
- 나쁜 설계: 새 기능을 넣을 때마다 비용이 증가

### 📖 잘못된 개발 패턴

**토끼와 거북이 우화의 교훈**

- 개발자들의 지나친 과신과 어리석음
- "코드는 나중에 정리하면 돼, 당장은 시장 출시가 먼저야!"
- 하지만 이전에 작성한 코드를 정리하는 일은 실제로 일어나지 않음

**핵심 진실**

```
"엉망으로 만들면 깔끔하게 유지할 때보다 항상 더 느리다"
"빨리 가는 유일한 방법은 제대로 가는 것이다"
```

💭 **개인 경험**

- 실제로 리액트나 Angular 등의 복잡한 프레임워크 없이도 순수 HTML, JS만으로 충분히 만들 수 있음
- 하지만 이런 것들을 배우는 이유는 "제대로" 만들고 최소한의 노력으로 기능과 유연성을 최대화하기 위함
- 훌륭한 소프트웨어 설계보다는 형편없는 설계와 맞서 싸우는 일이 더 많았다는 말에 공감..
- 부시고 다시 만들려 해도 원래 프로젝트와 똑같은 엉망으로 내몰리게 된다는 말이 정말 와닿음. 훈련이 안되어있는데 어떻게 좋은 설계를 할 수 있겠는가..

---

## 2장: 두 가지 가치에 대한 이야기

### 📖 소프트웨어의 두 가지 가치

#### 1. 행위 (Behavior)

- 프로그래머를 고용하는 이유: 이해관계자를 위해 수익 창출 또는 비용 절약
- 요구사항을 정의하고 코드를 작성하는 것

#### 2. 구조 (Architecture)

- **soft** = 부드러운, **ware** = 제품
- 소프트웨어는 "변경하기 쉬워야 한다"
- 기계의 행위를 바꾸기 어렵다면, 그것은 하드웨어라고 불렸을 것

### 📖 기능 vs 아키텍처 - 어떤 가치가 더 중요한가?

소프트웨어 시스템이 동작하게 만드는 것? 소프트웨어 시스템을 더 쉽게 변경할 수 있도록 하는 것?

**잘못된 인식**

- 업무 관리자의 답변: "당연히 동작"
- 개발자도 이에 동조하게 됨

**극단적 예시를 들어보자면,**

| 시스템 유형               | 특징                       | 결과            |
| ------------------------- | -------------------------- | --------------- |
| 완벽 동작하나 수정 불가   | 요구사항 변경 시 대응 불가 | 결국 쓸모없어짐 |
| 동작하지 않으나 변경 쉬움 | 수정과 유지보수 가능       | 더 유용함       |

결국 업무 관리자도 변경이 가능한 시스템을 원할 것이고, 추후에는 변경 요청을 하게 될 것이다.
이 때 "변경 비용이 너무 커서 현실적으로 적용할 수 없다" 라는 대답을 하면, "실질적으로 변경이 불가능한 상태에 처할 때까지 시스템을 방치했다" 라는 질책을 듣게 될 수 있을껄..

### 📖 아이젠하워 매트릭스

```
           긴급함          긴급하지 않음
         ┌─────────┬─────────────┐
중요함   │    1    │      2      │
         │ 긴급+중요│   중요만    │
         ├─────────┼─────────────┤
중요하지 │    3    │      4      │
않음     │ 긴급만  │   둘 다 X   │
         └─────────┴─────────────┘

• 행위 = 긴급하지만 매번 높은 중요도를 가지지 않음
• 아키텍처 = 중요하지만 즉각적인 긴급성을 필요로 하지 않음

우선순위:
1. 긴급하고 중요한
2. 긴급하지 않지만 중요한  ← 아키텍처
3. 긴급하지만 중요하지 않은  ← 행위
4. 긴급하지도 중요하지도 않은
```

### 📖 개발자의 책임

**투쟁하라!**

- 개발자는 "기능의 긴급성이 아닌 아키텍처의 중요성을 설득"하는 일에 책임을 져야 함
- 개발자도 이해관계자다
- 각 팀이 자신들이 믿는 가치를 위해 투쟁한다 - 개발자도 마찬가지여야 함

💭 **개인 생각**

- SI에서 일하며 고민: "주어진 기능이 잘 동작하도록" vs "주인의식을 가지고 잘 만들기"
- 나는 후자가 취향이지만, 현실적으로 동료들이나 고객사가 그걸 바라는지 불분명
- 하지만 소프트웨어 아키텍트라면 더 가치를 지녀야 하는 부분에 대한 확신과 맞서 싸울 용기가 필요
- "개발자도 이해관계자"라는 문장이 맞서 싸울 수 있는 자격과 근거를 제공해줌
- 깔끔하고 훌륭한 아키텍처 설계 = 중요하지만 긴급하지 않은 일

---

# 2부: 벽돌부터 시작하기: 프로그래밍 패러다임

## 3장: 패러다임 개요

### 📖 세 가지 프로그래밍 패러다임

| 패러다임                | 제한사항                           | 앗아간 것   | 시기 |
| ----------------------- | ---------------------------------- | ----------- | ---- |
| **구조적 프로그래밍**   | 제어흐름의 직접적 전환에 규칙 부과 | goto 문     | 1968 |
| **객체지향 프로그래밍** | 제어흐름의 간접적 전환에 규칙 부과 | 함수 포인터 | 1966 |
| **함수형 프로그래밍**   | 할당문에 규칙 부과                 | 할당문      | 1958 |

### 📖 패러다임의 완결성

**더 이상의 패러다임은 없다**

- goto, 함수 포인터, 할당문 외에 더 뺏길 게 있을까? 아마 없을 것
- 따라서 앞으로도 프로그래밍 패러다임은 이 3가지뿐일 것

### 📖 아키텍처와 패러다임의 관계

```
┌─────────────────────────────────────┐
│          아키텍처 관심사             │
├─────────────────────────────────────┤
│ 1. 함수                            │  ← 구조적 프로그래밍
│ 2. 컴포넌트 분리                   │  ← 객체지향 프로그래밍
│ 3. 데이터 관리                     │  ← 함수형 프로그래밍
└─────────────────────────────────────┘
```

**활용 방법**

- 아키텍처 경계를 넘나들기 위한 메커니즘으로 다형성 활용
- 함수형 프로그래밍으로 데이터 위치와 접근 방법에 대한 규칙 설정
- 모듈의 기반 알고리즘으로 구조적 프로그래밍 사용

💭 **개인 생각**

- "제어흐름의 간접적인 전환에 대한 규칙을 부과한다"는 말이 아직 완전히 이해되지 않음
- 1958~1968년 10년 사이에 나온 이 3가지 패러다임이 아직도 쓰이고 더 나오지 않았으므로, 이 세 가지만 잘 이해하면 충분할 것 같음

---

## 🔖 정리 및 다음 학습 방향

### 핵심 포인트

1. **아키텍처의 목표**: 인력 투입 최소화
2. **두 가지 가치**: 행위보다 구조(아키텍처)가 더 중요
3. **개발자의 책임**: 아키텍처의 중요성을 설득하고 투쟁
4. **패러다임의 본질**: 제약을 통한 질서 확립

### 다음 장 학습 포인트

- 각 패러다임의 구체적인 활용 방법
- 아키텍처 설계에서의 실제 적용 사례
- 컴포넌트 분리와 경계 설정 방법

---

_📝 1~3장 학습 완료일: 2025-08-26_
