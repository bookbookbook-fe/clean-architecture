# 📚 Week 2: 패러다임

## 📅 일정

**모임**: 9/17 (수)

## 📖 읽은 챕터

- 4장 - 구조적 프로그래밍
- 5장 - 객체 지향 프로그래밍
- 6장 - 함수형 프로그래밍

## 💭 주요 인사이트

### 🎯 핵심 논의 주제

**이론과 실무 적용의 괴리**

- **클린 아키텍처 실제 적용의 복잡성**:
  - 벨로시티 프로젝트에 클린 아키텍처 적용 시도 → 굉장히 복잡해짐
  - 모든 것을 엄격하게 나누는 것이 과연 맞는가에 대한 의문
  - "적당히 나누는" 기준과 균형점 찾기의 어려움
  - 규칙을 엄격하게 지키면서 나눠야 하는가 vs 실용적 접근

**백엔드 vs 프론트엔드 아키텍처 패러다임**

- **근본적 질문**: "백엔드 입장에서 쓰여진 책을 FE가 굳이 따라갈 필요가 있나?"
- **FE만의 아키텍처**: 백엔드 아키텍처를 억지로 가져오기보다는 프론트엔드만의 아키텍처 구축
- **생태계별 특성**: 프론트엔드 생태계가 편한 대로 접근하는 것의 타당성
- **도구의 목적성**: 아키텍처는 수단이지 목적이 아님

**객체지향 도입에 대한 고민**

- **도입 동기의 재검토**:

  - "프로그래머라면 당연히 객체지향을 경험해봐야 한다" vs "왜 굳이?"
  - 경험을 위한 기술 도입 vs 문제 해결을 위한 기술 도입
  - 프론트엔드 생태계에서 객체지향이 필요한 실질적 이유

- **객체지향의 가치**:
  - 책에서 제시하는 명확한 이유: 캡슐화, 상속, 다형성
  - 프로그래밍의 유연성과 유지보수성 향상
  - 변경 사항에 대한 대처 능력 강화

**패러다임 선택의 기준**

- **구조적 프로그래밍**: 순차, 분기, 반복을 통한 명확한 제어 흐름
- **객체지향 프로그래밍**: 다형성을 통한 의존성 제어와 플러그인 아키텍처
- **함수형 프로그래밍**: 불변성을 통한 동시성 문제 해결

- **선택의 딜레마**:
  - 각 패러다임이 해결하는 문제가 다름
  - 프론트엔드에서 어떤 패러다임이 더 적합한가?
  - 혼합 사용 시의 균형점과 기준

### 🎯 실무 적용 관점

**점진적 적용의 필요성**

- 이론을 한 번에 모두 적용하기보다는 단계별 접근
- 작은 단위부터 시스템 생태계까지 차근차근 확장
- 실제 프로젝트를 통한 검증과 조정

**패러다임별 활용 전략**

- **구조적 프로그래밍**: React 컴포넌트의 기능적 분해
- **객체지향**: 인터페이스를 통한 의존성 관리, 재사용 가능한 컴포넌트 설계
- **함수형**: Hook과 불변 상태 관리, 순수 함수를 통한 예측 가능한 로직

### 🎯 Action Item

- **실제 프로젝트에 점진적 적용**: 벨로시티 프로젝트에서 작은 단위부터 적용 실험
- **FE 아키텍처 패턴 연구**: 백엔드 패턴을 무작정 따르지 말고 FE 특성에 맞는 패턴 탐구
- **객체지향 실험**: 명확한 목적(캡슐화, 다형성 활용)을 가지고 FE에서 객체지향 패턴 시도
- **패러다임 혼합 사용**: 각 패러다임의 장점을 살린 조화로운 코드 구조 실험

---

## 📸 2주차 기념

> 🎉 **클린 아키텍처 2주차 완료!**
> 세 가지 프로그래밍 패러다임을 통해 프로그래밍의 본질에 대해 깊이 고민해본 시간이었습니다.
> 이론과 실무 사이의 간극을 인정하고, 프론트엔드만의 아키텍처를 찾아가는 여정의 시작! 🔍⚛️
