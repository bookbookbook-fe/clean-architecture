# 클린 아키텍처 스터디 - Week 2

| 장  | 제목                                              |
| --- | ------------------------------------------------- |
| 4장 | [구조적 프로그래밍](#4장-구조적-프로그래밍)       |
| 5장 | [객체 지향 프로그래밍](#5장-객체-지향-프로그래밍) |
| 6장 | [함수형 프로그래밍](#6장-함수형-프로그래밍)       |

## 4장: 구조적 프로그래밍

### 핵심 개념

- **구조적 프로그래밍의 정의**: 순차(sequence), 선택(selection), 반복(iteration)이라는 세 가지 구조만을 사용하여 프로그램을 작성하는 방법
- **무분별한 점프의 해로움**: goto문과 같은 직접적인 제어 전송은 프로그램의 구조를 해치고 이해를 어렵게 함

### 주요 원칙

1. **분해(Decomposition)**: 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해
2. **기능적 분해**: 큰 문제를 작은 문제들로 나누어 해결
3. **모듈화**: 각 모듈은 입증 가능하고 독립적으로 테스트 가능해야 함

### 테스트와 증명

- **다익스트라의 명제**: "테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보장할 수는 없다"
- **반증 가능성**: 테스트를 통해 증명 가능한 세부 기능들이 거짓인지를 증명하려고 시도
- **과학적 방법**: 올바름을 증명할 수는 없지만, 틀렸음을 증명할 수는 있음

### 현대적 의미

- **구조적 프로그래밍이 오늘날까지 가치 있는 이유**: 반증 가능한 단위를 만들어 낼 수 있는 능력
- **아키텍처 관점**: 기능적 분해를 통해 모듈과 컴포넌트의 기초가 됨

## 5장: 객체 지향 프로그래밍

### 객체 지향의 정의

- **객체 지향 프로그래밍의 본질**: 무엇인가보다는 무엇이 아닌가를 이해하는 것이 중요
- **세 가지 특성**: 캡슐화(encapsulation), 상속(inheritance), 다형성(polymorphism)

### 1. 캡슐화 (Encapsulation)

- **정의**: 데이터와 함수를 쉽고 효과적으로 캡슐화하는 방법을 제공
- **목적**: 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그음
- **한계**: 완벽한 캡슐화라고 할 수는 없으며, 실제로는 C언어에서도 어느 정도 가능

### 2. 상속 (Inheritance)

- **단순한 재정의**: 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 능력
- **편의성**: C언어에서도 수동으로 구현 가능하지만 OO(Object-Oriented) 언어가 더 편리함

### 3. 다형성 (Polymorphism)

- **핵심 특성**: 객체 지향에서 가장 중요한 특성
- **안전성**: 함수 포인터를 이용한 다형성은 위험했지만, OO(Object-Oriented) 언어는 이를 안전하고 편리하게 사용 가능
- **제어 능력**: 소스 코드 의존성을 원하는 방향으로 조절할 수 있는 능력

### 의존성 제어와 아키텍처

#### 전통적인 의존성 방향

- **제어 흐름**: main → 고수준 함수 → 중간 수준 함수 → 저수준 함수
- **소스 코드 의존성**: 제어 흐름을 따라 결정됨
- **문제점**: 제어 흐름은 시스템의 행위에 따라 결정되며, 소스 코드 의존성도 제어 흐름에 따라 결정

#### 의존성 역전 (Dependency Inversion)

**개념**

- **다형성의 힘**: 인터페이스를 통해 소스 코드 의존성 방향을 제어 흐름과 반대로 역전시킬 수 있음
- **핵심 원리**: 고수준 모듈이 저수준 모듈의 구현에 의존하지 않고, 둘 다 추상화에 의존하도록 함

**구체적인 예시**

```
기존 방식:
UI → Business Rules → Database
(소스코드 의존성이 제어 흐름을 따름)

의존성 역전 후:
UI → Business Rules ← Database
(Database가 Business Rules의 인터페이스에 의존)
```

**결과와 장점**

- **배포 독립성**: 각 컴포넌트를 독립적으로 배포 가능
- **개발 독립성**: 서로 다른 팀이 독립적으로 개발 가능
- **테스트 용이성**: Mock 객체를 이용한 단위 테스트 가능
- **유연성**: 구현체를 런타임에 교체 가능

### 현대적 의미

- **아키텍처적 관점**: 다형성을 이용해 플러그인 아키텍처 구현 가능
- **모듈 간 경계**: 고수준 모듈이 저수준 모듈에 의존하지 않도록 설계
- **유연한 시스템**: 변경에 유연하게 대응할 수 있는 시스템 구축

## 6장: 함수형 프로그래밍

### 핵심 개념

- **람다 계산법**: 함수형 프로그래밍의 수학적 기초
- **불변성**: 함수형 언어에서 변수는 변경되지 않는다
- **클로저**: 함수가 정의된 환경의 변수들을 기억하는 기능

### 가변 변수의 문제점

함수형 프로그래밍이 중요한 이유는 가변 변수로 인한 동시성 문제를 해결할 수 있기 때문입니다.

**가변 변수로 인한 주요 문제들:**
1. **경합 조건(Race Condition)**: 여러 스레드가 동시에 같은 변수에 접근할 때 발생
2. **교착 상태(Deadlock)**: 두 개 이상의 스레드가 서로를 기다리며 무한 대기하는 상태
3. **동시 업데이트(Concurrent Update)**: 동시에 같은 데이터를 수정하려 할 때 발생하는 문제

**핵심 원리:**
> 가변 변수가 없다면 동시성 애플리케이션에서 마주치는 모든 문제가 절대로 생기지 않는다

### 함수형 프로그래밍의 해결책

#### 1. 불변성 (Immutability)
- 한 번 할당된 변수는 절대 변경되지 않음
- 새로운 값이 필요하면 새로운 변수를 생성

#### 2. 트랜잭션 메모리
- 데이터베이스의 트랜잭션과 유사한 개념을 메모리에 적용
- 동시성 제어를 위한 메커니즘

#### 3. 이벤트 소싱
- **핵심 전략**: 상태가 아닌 트랜잭션을 저장하는 전략
- 현재 상태 대신 상태를 변경한 이벤트들을 저장
- 필요 시 이벤트들을 재실행하여 현재 상태를 복원

### 세 패러다임의 본질

각 패러다임은 프로그래밍에서 특정 능력을 **제거**함으로써 규율을 부과합니다:

1. **구조적 프로그래밍**: 제어 흐름의 직접적인 전환에 부과되는 규율 (goto문 제거)
2. **객체 지향 프로그래밍**: 제어 흐름의 간접적인 전환에 부과되는 규율 (함수 포인터 제거)
3. **함수형 프로그래밍**: 변수 할당에 부과되는 규율 (가변성 제거)

### 현대적 의미

- **동시성 프로그래밍**: 멀티코어, 분산 시스템에서 안전한 프로그래밍
- **예측 가능성**: 불변 데이터로 인한 예측 가능한 동작
- **테스트 용이성**: 부작용이 없어 테스트가 쉬움

### 소프트웨어의 본질

> 소프트웨어는 순차(sequence), 분기(selection), 반복(iteration), 참조(indirection)으로 구성된다. 그 이상도 그 이하도 아니다.
