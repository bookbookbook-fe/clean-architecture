# 🧹 클린 아키텍처 스터디 2주차 (4~6장) 요약

---

### 4. 구조적 프로그래밍 (Structured Programming)

> **"프로그래밍에서 `goto` 문은 해롭다."**

구조적 프로그래밍은 **제어 흐름을 직접적으로 통제**하는 것에 대한 규칙입니다. 데이크스트라(Dijkstra)는 `goto` 문의 무분별한 사용이 프로그램 구조를 파괴하고, 모듈을 증명 가능한 단위로 분해하는 것을 불가능하게 만든다는 사실을 발견했습니다.

- **핵심 원칙**: 모든 프로그램은 **순차(Sequence), 분기(Selection), 반복(Iteration)** 이 세 가지 구조만으로 표현할 수 있습니다.

  - **순차**: 코드는 위에서 아래로 순서대로 실행됩니다.
  - **분기**: `if/else`, `switch` 문을 통해 조건에 따라 다른 코드를 실행합니다.
  - **반복**: `for`, `while` 문을 통해 특정 코드를 반복 실행합니다.

- **기능적 분해 (Functional Decomposition)**
  - 이러한 구조를 통해 거대한 문제를 작은 함수(기une) 단위로 분해하고, 다시 이 함수들을 조합하여 전체 시스템을 구축할 수 있게 되었습니다.
  - 이는 현대 프로그래밍 언어의 근간이 되었습니다.

> **증명 가능한 코딩**
>
> 구조적 프로그래밍을 통해 우리는 코드를 수학적인 단위처럼 테스트하고, 그 정당성을 증명할 수 있게 되었습니다. 즉, **과학적인 접근**이 가능해진 것입니다.

---

### 5. 객체 지향 프로그래밍 (Object-Oriented Programming)

> **"객체 지향이란 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다."**

흔히 **캡슐화, 상속, 다형성**을 OOP의 세 가지 기둥이라고 하지만, 저자는 이 중 **다형성(Polymorphism)**이 가장 핵심이라고 강조합니다.

- **캡슐화 (Encapsulation)**

  - 데이터와 그 데이터를 처리하는 함수를 하나의 단위로 묶고, 외부에서는 데이터에 직접 접근하지 못하도록 숨기는 것입니다.
  - 하지만 C언어에서도 헤더 파일(`.h`)과 소스 파일(`.c`)을 통해 완벽한 캡슐화를 구현할 수 있었기에, OOP만의 고유한 개념은 아닙니다.

- **상속 (Inheritance)**

  - 기존 클래스의 변수와 함수를 새로운 클래스에서 재사용하는 기능입니다.
  - 상속 역시 OOP 이전에도 존재했던 개념이며, 편리한 재사용 메커니즘일 뿐 핵심은 아닙니다.

- **다형성 (Polymorphism) ✨**
  - **제어 흐름을 간접적으로 전환**하는 규칙입니다.
  - 인터페이스(또는 추상 클래스)를 통해 시스템의 의존성을 역전(**Dependency Inversion**)시킬 수 있습니다.
  - **예시**: 상위 수준의 모듈(A)이 하위 수준의 모듈(B)에 직접 의존하지 않고, 중간에 있는 **인터페이스(I)**에 의존하게 만드는 것입니다.
  - 이를 통해 B 모듈을 수정하거나 다른 모듈(C)로 교체하더라도, A 모듈은 전혀 영향을 받지 않습니다. 즉, **플러그인 아키텍처(Plugin Architecture)**를 가능하게 합니다.

> **진정한 힘: 의존성 역전**
>
> 객체 지향 프로그래밍의 진짜 강력함은 **소스 코드의 의존성 방향을 마음대로 제어**할 수 있다는 점입니다. 이를 통해 시스템을 더 유연하고, 확장 가능하며, 유지보수하기 쉽게 만들 수 있습니다.

---

### 6. 함수형 프로그래밍 (Functional Programming)

> **"함수형 프로그래밍이란 불변성(Immutability)을 통해 동시성 문제를 해결하는 방법이다."**

함수형 프로그래밍의 핵심은 **"할당문(assignment)은 해롭다"**는 것입니다. 즉, 한 번 초기화된 변수는 절대 변하지 않는다는 **불변성**을 기본 원칙으로 합니다.

- **왜 불변성이 중요한가?**

  - **경합 조건 (Race Condition), 교착 상태 (Deadlock), 동시 업데이트 (Concurrent Update)**와 같은 동시성(Concurrency) 문제는 대부분 **가변 변수(Mutable Variable)** 때문에 발생합니다.
  - 여러 스레드가 동시에 하나의 변수 값을 변경하려고 할 때 문제가 생기는 것이죠.
  - 만약 모든 변수가 **불변(Immutable)**이라면, 이런 문제는 원천적으로 발생하지 않습니다.

- **불변성과 아키텍처**
  - **이벤트 소싱 (Event Sourcing)**: 상태를 직접 변경하고 저장하는 대신, 상태를 변경하는 **'이벤트'** 들을 순서대로 저장하는 아키텍처 패턴입니다.
    - 예: 은행 계좌에서 잔액(`balance`)을 직접 수정하는 대신, `입금`, `출금`과 같은 트랜잭션(이벤트)을 계속 기록합니다. 현재 잔액은 모든 트랜잭션을 처음부터 계산하면 언제든지 알 수 있습니다.
    - 이는 완전한 함수형 프로그래밍이며, 저장 공간과 처리 능력만 충분하다면 완벽한 솔루션이 될 수 있습니다.

> **CQRS (Command Query Responsibility Segregation)**
>
> 상태를 변경하는 **명령(Command)**과 상태를 조회하는 **조회(Query)**의 책임을 분리하는 패턴입니다. 이는 이벤트 소싱과 같은 함수형 아키-텍처에서 자주 사용됩니다.
