## 4장 구조적 프로그래밍 

> 데이크스트라가 초기에 인식한 문제는 프로그래밍은 어렵고, 프로그래머는 프로그래밍을 잘하지 못한다는 사실이었다.

기존의 제한이 없었던 C언어 등은 goto 문이 많이 사용하였고, goto문은 인간의 두뇌로 이해하기엔 어려운 구조였다.
하지만 goto 문장을 사용한 경우에도 모듈을 분해할때 문제가 되지않는 구조가 있었는데 좋은 사용방식은 선택/반복 (if/for문 등) 과 같은 단순한 제어구조에 해당한다는 사실을 발견했다. 여기에 순차 실행까지 합쳐서 (순차,선택,반복) 이 세가지 구조만으로 모든 프로그램을 표현할수 있다는 것을 증명했다.

1. 순차구문 
순차구문은 열거법으로 차례대로 실행하기때문에, 하나씩 나열해서 증명 a = 0 이다. 

2. 선택구문
선택구문도 열거법으로 조건에 맞게 선택된 결과를 나열해서 증명 한다.

3. 반복구문
반복구문은 무한히 반복될수 있으므로, 기초단계 + 귀납단계로 증명했다.

즉, 데이크스트라는 이 세가지 구조가 모든 프로그램을 수학적으로 증명할수 있다고 밝힌것이다.

> 엄밀한 증명은 없었다.

안타깝게도 프로그램 관점에서 정리에 대한 유클리드 계층구조는 끝내 만들어지지 않았다.
그리고 프로그램을 만들때 프로그래머들은 엄밀한 수학적 증명에 관심을 가지지 않았다.

하지만 수학은 증명가능한 서술이 참임을 입증하는 원리라면, 과학은 증명가능한 서술이 거짓임을 입증하는 원리로,
과학적으로 접근한다면, 증명이 되어야 참이 아닌 많은 노력으로 반례를 들수 없는 서술이 있다면 목표에 부합할 만큼 참이라고 여길수가 있다. (약간은 정신승리 같지만, 프로그램을 꼭 수학적으로 증명해야하는 이유도 없기도 하다, 사실 수학도 증명할수 없다 괴델의 불완전성의 원리로 수학의 모순을 밝혔다)


> 테스트

과학적으로 접근하여 반례를 들수 없는 서술식을 만들기위해서 테스트 구문을 작성하는 방식으로 프로그램을 증명하기위해 노력했다 소프트웨어는 과학과 같고, 따라서 반증 가능성에 의해 주도된다. *즉, 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증가능하도록 만들기 위해 노력해야 한다.*


## 5장 객체 지향 프로그래밍

> 캡슐화, 상속, 다형성

캡슐화는 객체지향프로그래밍에 국한된 것은 아니지만, OOP언어가 쉽고 효과적으로 구현할수가 있다.

캡슐화는 구현 세부사항을 외부에 감추고, 추상화된 인터페이스를 제공하는 것이다.

상속은 OOP의 특징중 하나이지만, 부모와 자식관계에 종속성이 생기기 때문에 결합도가 높아지는 단점이 있어서 중요하지 않다.

다형성은 제일 중요한 OOP의 특성중 하나이다. 의존성의 역전 원칙(DIP), 의존성의 주입(DI) 방법처럼 추상화된 인터페이스를 설계해서 모듈간의 결합도를 낮추며, 시스템을 유연하고 확장가능하도록 설계할수 있다.

객체지향프로그래밍을 사용하므로써 프로그램을 모듈별로 독립적으로 개발, 배포할수 있으며, 다형성을 활용하여 모든 소스코드의 의존성에 대한 절대적인 제어 권한을 획득할수 있다고 표현한다.

## 6장 함수형 프로그래밍

> 함수형 프로그래밍의 차이

함수형프로그래밍은 변수를 쓰고 버린다는 차이가 OOP에선 값을 변화시키는 것과 다른점이긴하다.

SPA중에 처음엔 모두 class 로 생성하여 컴포넌트를 만들어 사용했었다. 이후 함수형으로 컴포넌트를 생성할수 있게 만들어졌고 이제는 모두 함수형으로 컴포넌트를 생성한다. 가변상태를 직접 다루면 값이 어떻게 바뀌는지 데이터의 흐름을 이해하기 어려웠고, 함수형 컴포넌트는 입력 -> 출력 으로 단순해졌으며, 테스트도 편해졌다.

데드락, 동시성 오류 등은 모두 가변변수에 의해서 발생하는 이슈들이다. 변수를 불변하도록 한다면, 이와같은 문제들을 걱정하지않아도 된다. 또한 100% 불변변수를 사용할수 없으니, 최대한 인프라, I/O 로 몰아내고, 순수함수/불변변수를 사용하도록 권장한다.

> 이벤트 소싱

깃처럼 상태값을 덮어쓰지 않고 로그를 축적해가면서 최종 상태를 재구성하는 접근을 이벤트 소싱이라고 한다.

> 결론

소프트웨어의 핵심은 예전과 오늘날 그대로다. 순차,분기,반복,참조로 이루어져있다.
