# 📚 Week 3: SRP, OCP, LSP

## 📅 일정

**모임**: 9/24 (수)

## 📖 읽은 챕터

- 7장 - SRP: 단일 책임 원칙
- 8장 - OCP: 개방-폐쇄 원칙
- 9장 - LSP: 리스코프 치환 원칙

## 💭 주요 인사이트

### SRP (단일 책임 원칙)

**SRP의 정확한 의미**

- 흔한 오해: "모듈 하나에는 하나의 기능만 있어야 한다"
- 정확한 정의: "하나의 모듈은 변경의 이유가 단 하나여야 한다"
- SRP는 함수, 클래스, 모듈, 파일 등 다양한 수준에서 적용 가능

**실무에서 SRP 위반을 의심해볼 수 있는 징후**

- 한 파일에 여러 컴포넌트를 export하는 경우
- 병합 충돌이 빈번하게 발생하는 파일: 여러 개발자가 같은 파일의 서로 다른 기능을 동시에 수정
- 다만 같은 도메인의 기능들을 한 파일에 모은 경우는 애매한 영역

**토론 포인트**

- 같은 도메인 기능을 한 파일에 모으는 것이 SRP 위반일까?
- 도메인이 다른 경우가 더 명확한 SRP 위반 사례
- 병합 충돌이 항상 SRP 위반을 의미하는 것은 아님

### OCP (개방-폐쇄 원칙)

**핵심 개념**

- 확장에는 열려있고, 수정에는 닫혀있어야 함
- 새로운 기능 추가 시 기존 코드를 수정하지 않고 확장 가능해야 함

**실무 사례와 고민**

- 처음에는 예상하지 못한 규모(예: 800개 케이스)로 요구사항이 확장될 수 있음
- 기존 코드를 계속 수정해야 하는 구조는 OCP 위반이며 어디서 문제가 발생할지 예측 불가
- 처음 설계부터 변경에 잘 적응할 수 있는 구조를 고민해야 함

**컴포넌트 패턴과 OCP**

- 컴포넌트 패턴으로 SRP와 OCP를 동시에 충족 가능
- 흩어져 있는 것들을 인터페이스로 묶어 응집도 향상
- 새로운 구현 추가 시 기존 코드 수정 없이 확장

### 컴포넌트 패턴 실무 적용

**잘 설계된 컴포넌트 패턴의 특징**

- 컴포넌트를 통해서만 접근 가능하도록 설계
- 컨텍스트가 하나로 관리되어 있음
- 각 컴포넌트는 단 하나의 일만 수행

**React Hook Form 활용**

- useFormContext로 자식 컴포넌트에서 Form 상태 접근 가능하여 재사용성 향상
- 고민: Control UI만 담당하는 컴포넌트를 구조화하는 명확한 기준 필요

**Factory 패턴 적용**

- 각 서비스별로 데이터 소스를 분리하고 인터페이스로 묶음
- 새로운 데이터 소스 추가 시: 데이터 소스 구현체만 추가하고 팩토리에 등록
- 각각 상속받아 구현하는 구조로 확장성 확보

### LSP (리스코프 치환 원칙)

**핵심 개념**

- 하위 타입은 상위 타입을 완전히 대체할 수 있어야 함
- 클라이언트는 상위 타입과 하위 타입의 차이를 알 필요가 없어야 함
- 상위 타입이 예상하는 결과를 하위 타입도 내보내야 함

**하위 타입의 기능 추가에 대한 오해**

- 질문: "하위 타입에서 기능을 추가하면 상위 타입은 못 쓰는 거 아닌가?"
- 답변: 추가 기능은 문제없음. 단, 상위 타입의 계약은 반드시 지켜야 함

**고전 예제: Rectangle과 Square**

- Rectangle 클래스: setWidth와 setHeight를 독립적으로 설정 가능
- Square 클래스: setWidth를 호출하면 height도 함께 변경됨 (정사각형 특성)
- 문제: Rectangle을 기대하는 코드에 Square를 넣으면 예상과 다른 결과 발생
- Rectangle은 width와 height를 독립적으로 설정 가능하지만, Square는 불가능
- 수학적으로는 "정사각형 is-a 직사각형"이지만 프로그래밍에서는 LSP 위반

**토론 결과와 해결 방법**

- "테스트를 잘못 짠 게 아니라 상속 관계 자체가 잘못됨"
- Rectangle과 Square를 Shape의 하위 타입으로 형제 관계로 설계
- Shape에서는 width/height 독립 설정에 대한 제약 없음
- Square는 width/height가 아닌 단일 size 속성 사용
- 극도로 추상화하여 각자의 특성 유지

### 다형성과 LSP

**다형성의 의미**

- 한 인터페이스로 여러 타입을 다룰 수 있는 능력
- 문법적인 능력, 프로그래밍 언어가 제공하는 도구
- 밖에서 봤을 때 같은 인터페이스를 구현하는 것
- 인터페이스만 같으면 타입 체크를 통과

**LSP와 다형성의 관계**

- 다형성은 도구 (문법적 기능)
- LSP는 도구를 올바르게 사용하는 방법 (의미론적 규칙)
- LSP는 다형성이 의미론적으로 올바르게 동작하도록 보장하는 설계 원칙
- 인터페이스만 맞추는 것이 아니라 내부 구현까지 올바르게 해야 함
- 다형성을 활용하되 LSP를 위반하지 않게 하는 것이 중요

**레거시 코드 사례**

- SOLID 원칙이 모두 위반된 코드
- 확장은 열려있지만 기존 코드를 계속 수정해야 함
- 변경에 닫혀있지 않아 어디서 문제가 발생할지 예측 불가

### 핵심 배운 점

1. SRP: "하나의 기능"이 아닌 "하나의 변경 이유"
2. OCP: 컴포넌트 패턴으로 SRP + OCP 동시 달성 가능
3. LSP: 단순 타입 호환이 아닌 행위(계약) 호환이 핵심
4. 다형성 vs LSP: 다형성(도구)과 LSP(올바른 사용법)는 다른 개념
5. 설계 원칙: 처음부터 변경을 고려한 확장 가능한 구조 설계 필요
