# 🧹 클린 아키텍처 스터디 3주차 (7~9장) 요약

---

### 7. 단일 책임 원칙 (SRP: Single Responsibility Principle)

> "하나의 모듈은 오직 하나의 배우(Actor)에 대해서만 책임져야 한다."

- **핵심**

  - SRP는 _하나의 클래스/모듈이 단 하나의 변경 이유만_ 가져야 함을 의미한다.
  - 여기서의 "책임"은 기능 목록이 아니라, **변경의 이유(Reason to change)** 이다.
  - 서로 다른 이해관계자(배우)가 같은 모듈의 변경을 초래한다면, 그 모듈은 SRP를 위반하고 있다.

- **균열의 징후**

  - **산탄총 수술(Shotgun Surgery)**: 사소한 변경에도 여러 파일을 동시에 수정해야 한다.
  - **우발적 결합(Accidental Coupling)**: 서로 다른 역할의 코드가 한 파일에 섞여 있어 변경 파급이 커진다.

- **좋은 분리의 기준**

  - **역할(Actor) 기준 분리**: 정책(비즈니스 규칙), UI, 영속성, 배포/운영 등은 보통 다른 배우를 가진다.
  - **변경 이유 기준 분리**: "누구의 요청으로 바뀌는가?"를 묻고, 그 축이 다르면 모듈 분리.

- **실무 팁**
  - **Use Case/Interactor**와 **Presenter/View**를 분리해 UI 변경이 도메인에 번지지 않도록 한다.
  - **Facade/Adapter**로 외부 시스템 의존을 격리한다.
  - 동시성, 배포 단위, 팀 경계도 SRP의 실질적 분리 축이 될 수 있다.

---

### 8. 개방-폐쇄 원칙 (OCP: Open-Closed Principle)

> "소프트웨어 엔티티는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다."

- **핵심**

  - 새로운 기능을 추가할 때 기존 코드의 **변경을 최소화**하거나 **없이** 확장으로 대응하자는 원칙.
  - 이를 위해 **다형성/추상화**를 활용해 정책과 구현을 분리한다.

- **아키텍처 관점**

  - **플러그인 아키텍처**: 안정된 정책(핵심 비즈니스 규칙)에 대한 의존성 방향을 고정하고, 가변 세부사항(UI, DB, 프레임워크)을 플러그인으로 취급한다.
  - **안정-불안정 경계**: 자주 바뀌는 것(불안정)은 안정된 것 뒤에 숨기고, 인터페이스로 격리한다.

- **구현 패턴**

  - **전략(Strategy), 템플릿 메서드(Template Method)**: 정책은 상위에, 가변 구현은 하위에 위치시켜 교체 가능하게 한다.
  - **DIP(의존성 역전)와의 연계**: 상위 정책이 하위 구현의 세부사항이 아닌 **추상화**에 의존하도록 설계한다.

- **효과**
  - 기능 추가 시 영향 범위가 작아져 **회귀 버그** 위험이 줄고, **병렬 개발**이 쉬워진다.

---

### 9. 리스코프 치환 원칙 (LSP: Liskov Substitution Principle)

> "하위형은 언제나 상위형으로 대체 가능해야 한다."

- **핵심**

  - 클라이언트는 상위 타입의 계약(Contract)을 가정하고 사용한다. 하위 타입은 그 **계약을 깨지 않고** 대체되어야 한다.
  - 전제조건은 **완화**(더 적은 요구), 사후조건은 **강화**(더 강한 보장)되거나 최소한 유지되어야 한다.

- **고전적 함정: 사각형-정사각형 문제**

  - 정사각형을 사각형의 하위 타입으로 두면, 폭/높이를 독립적으로 설정하는 사각형의 계약을 위반한다.
  - 해결: 상속 대신 **역할/행동을 재정의**하거나, **구성(Composition)**으로 모델링한다.

- **냄새와 대처**
  - 런타임에 `type` 체크로 분기한다면 LSP 위반의 신호일 수 있다 → **다형성**으로 치환.
  - 인터페이스가 너무 넓으면 일부 하위 타입이 계약을 지키기 어렵다 → **인터페이스 분리(ISP)** 적용.
  - 도메인 불변식(invariant)을 하위 타입에서도 **항상 유지**되도록 테스트로 보장한다.

---

### 마무리: SRP · OCP · LSP의 연결

- **SRP**는 변경 이유를 분리해 모듈의 응집을 높이고, 변경 파급을 줄인다.
- **OCP**는 그 분리된 경계에 추상화를 두어, 기능 추가를 "확장"으로 흡수한다.
- **LSP**는 그 추상화의 **계약**을 지키게 하여, 안전한 대체/교체를 가능하게 한다.

세 원칙은 함께 적용될 때 가장 강력해진다. 역할에 따라 분리(SRP)하고, 추상으로 의존(OCP/DIP)하며, 계약을 지키는 대체 가능성(LSP)으로 플러그인 아키텍처를 완성하자.
