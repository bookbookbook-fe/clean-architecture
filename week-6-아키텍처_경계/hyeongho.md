# 15장 - 아키텍처란?

## 소프트웨어 아키텍처의 정의

### 아키텍처란 무엇인가?

> 💡 **핵심**: 소프트웨어 시스템의 아키텍처는 시스템을 구축했던 사람들이 만들어낸 **시스템의 형태**

**아키텍처의 형태를 결정하는 3가지 요소:**

```
┌─────────────────────────────────────────┐
│      소프트웨어 아키텍처의 구성 요소      │
├─────────────────────────────────────────┤
│                                         │
│  ① 시스템을 컴포넌트로 분할하는 방법     │
│            ↓                            │
│  ② 분할된 컴포넌트를 배치하는 방법       │
│            ↓                            │
│  ③ 컴포넌트가 서로 의사소통하는 방식     │
│                                         │
└─────────────────────────────────────────┘
```

---

## 아키텍처의 목적

### 시스템 생명주기 지원

> 💡 **아키텍처의 주된 목적**: 시스템의 생명주기를 지원하는 것

**아키텍처가 중요한 단계:**

```
운영 단계      ❌ 큰 문제 없음
    ↓
배포 단계      ⚠️ 어려움 시작
    ↓
유지보수 단계   ⚠️ 가장 큰 어려움
    ↓
계속되는 개발   ⚠️ 지속적인 어려움
```

### 궁극적인 목표

**아키텍처가 달성해야 할 4가지:**

```
┌──────────────┐
│ 좋은 아키텍처 │
└──────┬───────┘
       │
       ├──→ ✅ 쉽게 이해
       │
       ├──→ ✅ 쉽게 개발
       │
       ├──→ ✅ 쉽게 유지보수
       │
       └──→ ✅ 쉽게 배포
```

**최종 목표:**

```
┌─────────────────────┐      ┌─────────────────────┐
│   시스템 수명 관련   │      │  프로그래머 생산성   │
│      비용 감소      │  +   │       최대화        │
└─────────────────────┘      └─────────────────────┘
```

---

## 유지보수의 비용

### 탐사(Exploration)의 비용

> ⚠️ **중요**: 유지보수의 가장 큰 비용은 **탐사**와 이로 인한 **위험부담**

**탐사란?**

기존 소프트웨어에 새로운 기능을 추가하거나 결함을 수정할 때:

- 소프트웨어를 파헤쳐서 **어디를 고치는게 최선인지** 결정
- **어떤 전략을 쓰는게 최적일지** 판단
- 이 과정에서 발생하는 **시간과 노력**

**탐사 비용 구조:**

```
새로운 기능 추가 or 버그 수정
         ↓
┌─────────────────────┐
│   탐사 단계 시작     │
├─────────────────────┤
│ • 코드 분석          │
│ • 영향 범위 파악     │  ← ⚠️ 가장 큰 비용 발생
│ • 최선의 방법 결정   │
│ • 위험 요소 평가     │
└─────────────────────┘
         ↓
    실제 구현 단계
```

---

## 좋은 아키텍트의 역할

### 정책과 세부사항의 분리

> 💡 **핵심 원칙**: 세부사항을 정책으로부터 신중하게 가려내고, 정책이 세부사항과 결합되지 않도록 **엄격하게 분리**

**분리의 결과:**

```
┌─────────────────┐
│     정책        │  ← 비즈니스 로직, 핵심 규칙
│  (Policy)       │
└────────┬────────┘
         │
         │ ❌ 의존하지 않음
         │
         ↓
┌─────────────────┐
│   세부사항       │  ← 데이터베이스, UI, 프레임워크
│  (Details)      │
└─────────────────┘
```

**좋은 아키텍처의 특징:**

| 측면              | 설명                                           |
| ----------------- | ---------------------------------------------- |
| **정책의 독립성** | 정책은 세부사항에 관한 어떠한 지식도 갖지 않음 |
| **의존성 방향**   | 정책이 세부사항에 의존하지 않음                |
| **결정 지연**     | 세부사항에 대한 결정을 가능한 한 오랫동안 미룸 |

### 결정 지연 전략

**좋은 아키텍트의 핵심 전략:**

```
프로젝트 초기
    ↓
┌─────────────────────────┐
│  정책(핵심 로직)만 설계  │  ✅ 먼저 집중
└─────────────────────────┘
    ↓
    ⏱️ 가능한 한 오래 미룸
    ↓
┌─────────────────────────┐
│   세부사항 결정         │  ✅ 나중에 결정
│ • 데이터베이스 선택     │
│ • 웹서버 선택           │
│ • 프레임워크 선택       │
│ • 외부 인터페이스       │
└─────────────────────────┘
```

**결정 지연의 장점:**

```
결정 지연
    ↓
┌─────────────────────────┐
│  장점 1: 더 많은 정보    │
│  • 충분한 고민 시간     │
│  • 실제 요구사항 파악   │
└─────────────────────────┘
    ↓
┌─────────────────────────┐
│  장점 2: 실험 가능       │
│  • 여러 대안 시도       │
│  • 최선의 선택 가능     │
└─────────────────────────┘
    ↓
┌─────────────────────────┐
│  장점 3: 변경 용이       │
│  • 선택 변경 쉬움       │
│  • 비용 최소화          │
└─────────────────────────┘
```

# 16장 - 독립성

## 좋은 아키텍처가 지원하는 것

> 💡 **핵심**: 좋은 아키텍처는 시스템의 **유스케이스**, **운영**, **개발**, **배포**를 지원한다.

**좋은 아키텍처의 4가지 지원 영역:**

```
┌──────────────────────────┐
│   좋은 아키텍처가        │
│   지원해야 하는 것       │
├──────────────────────────┤
│                          │
│  ① 유스케이스 (Use Case) │
│  ② 운영 (Operation)      │
│  ③ 개발 (Development)    │
│  ④ 배포 (Deployment)     │
│                          │
└──────────────────────────┘
```

---

## 유스케이스 (Use Case)

### 시스템의 의도 지원

> 💡 **아키텍트의 최우선 관심사**: 시스템의 의도를 명확하게 지원해야 한다.

**유스케이스 중심 아키텍처:**

```
┌────────────────────────┐
│  시스템 최상위 구조     │
├────────────────────────┤
│ • 행위가 일급 요소      │  ✅ 쉽게 알아볼 수 있음
│ • 의도가 명확함         │  ✅ 찾아 헤매지 않음
│ • 유스케이스가 보임     │  ✅ 개발자 친화적
└────────────────────────┘
```

**Before vs After 비교:**

| 측면            | ❌ 나쁜 아키텍처 | ✅ 좋은 아키텍처     |
| --------------- | ---------------- | -------------------- |
| **의도 파악**   | 코드를 뒤져야 함 | 최상위에서 바로 보임 |
| **행위 위치**   | 흩어져 있음      | 일급 요소로 명확     |
| **개발자 경험** | 찾아 헤맴        | 직관적으로 이해      |

---

## 운영 (Operation)

### 성능 요구사항 보장

> ⚠️ **중요**: 아키텍처는 각 유스케이스에 걸맞은 **처리량**과 **응답 시간**을 보장해야 한다.

**운영 요구사항 예시:**

```
시스템 운영 요구사항
         ↓
┌─────────────────────────┐
│ 초당 100,000명의 고객    │
│ 처리 필요                │
└─────────────────────────┘
         ↓
┌─────────────────────────┐
│ 아키텍처가 보장해야 할 것│
├─────────────────────────┤
│ • 적절한 처리량          │
│ • 빠른 응답 시간         │
│ • 확장 가능한 구조       │
└─────────────────────────┘
```

---

## 개발 (Development)

### 콘웨이의 법칙 (Conway's Law)

> 💡 **콘웨이의 법칙**: 시스템을 설계하는 조직이라면 어디든지 그 조직의 **의사소통 구조**와 동일한 구조의 설계를 만들어 낼 것이다.

**팀 구조와 아키텍처:**

```
조직 구조               아키텍처 구조
┌─────────┐            ┌─────────┐
│  팀 A   │ ────────→  │ 모듈 A  │
│  팀 B   │ ────────→  │ 모듈 B  │
│  팀 C   │ ────────→  │ 모듈 C  │
└─────────┘            └─────────┘
```

### 독립적인 팀 개발

**좋은 아키텍처의 개발 지원:**

```
❌ 나쁜 아키텍처             ✅ 좋은 아키텍처
┌──────────────┐            ┌─────┐ ┌─────┐
│ 강하게 결합된 │            │팀 A │ │팀 B │
│ 단일 모듈    │            │독립 │ │독립 │
│             │            └─────┘ └─────┘
│ 팀들이 서로  │                  ↓
│ 방해함       │            서로 방해하지 않음
└──────────────┘
```

**원칙:**

- 각 팀이 **독립적으로 행동**하기 편한 아키텍처
- 개발하는 동안 팀들이 **서로를 방해하지 않음**
- 다양한 관심사를 가진 조직에서 필수

---

## 배포 (Deployment)

### 즉각 배포 가능한 시스템

> 💡 **좋은 아키텍처**: 시스템이 빌드된 이후 **즉각 배포**할 수 있도록 지원

**배포 방식 비교:**

```
❌ 나쁜 아키텍처
┌────────────────────────┐
│ 수십 개의 설정 파일 수정│
│ 복잡한 스크립트 실행    │
│ 배포에 시간 소요        │
└────────────────────────┘

✅ 좋은 아키텍처
┌────────────────────────┐
│ 빌드 완료               │
│      ↓                 │
│ 즉각 배포 가능          │
└────────────────────────┘
```

---

## 선택사항 열어놓기

### 유연한 변경 가능성

> 💡 **핵심 전략**: 선택사항을 열어 둠으로써, 향후 시스템에 변경이 필요할 때 **어떤 방향으로든 쉽게 변경** 가능

**선택사항 열어놓기의 효과:**

```
         현재
          ↓
┌──────────────────┐
│ 선택사항 열어둠   │
└──────────────────┘
     ↙    ↓    ↘
  옵션A  옵션B  옵션C

향후 어떤 방향으로든 변경 가능
```

---

## 계층 결합 분리

### SRP와 CCP 적용

> 💡 **원칙 적용**: 단일 책임 원칙(SRP)과 공통 폐쇄 원칙(CCP)을 적용하여 분리

**분리 기준:**

```
┌─────────────────────────┐
│   변경 이유에 따른 분리  │
├─────────────────────────┤
│                         │
│ 다른 이유로 변경         │
│      ↓                  │
│    분리 (Separate)      │
│                         │
│ 동일한 이유로 변경       │
│      ↓                  │
│    묶음 (Group)         │
│                         │
└─────────────────────────┘
```

**계층 분리 결과:**

```
┌──────────────┐
│  UI Layer    │  ← UI 변경 시
├──────────────┤
│ Business     │  ← 비즈니스 로직 변경 시
│ Logic Layer  │
├──────────────┤
│  Data Layer  │  ← 데이터 구조 변경 시
└──────────────┘
```

---

## 유스케이스 결합 분리

### 수평적 + 수직적 분할

> 💡 **핵심**: 시스템을 **수평적 계층**으로 분할하면서 동시에 **수직적인 유스케이스**로 분할

**2차원 분할 구조:**

```
수평적 계층 분할
────────────────────────────→
│  UI Layer     │ │ │ │ │
├──────────────┤ │ │ │ │  ↓ 수직적
│ Business     │ │ │ │ │  ↓ 유스케이스
│ Logic Layer  │ │ │ │ │  ↓ 분할
├──────────────┤ │ │ │ │  ↓
│  Data Layer  │ │ │ │ │

    UC1 UC2 UC3 UC4 UC5
    (얇은 수직 슬라이스)
```

**장점:**

- 각 유스케이스가 **독립적**으로 수직 슬라이스 형성
- 계층별 관심사 분리 + 기능별 관심사 분리 **동시 달성**

---

## 독립성의 종류

### 개발 독립성 (Development Independence)

> ✅ **효과**: 컴포넌트가 완전히 분리되면 **팀 사이의 간섭이 줄어든다**

```
┌─────────┐  ┌─────────┐  ┌─────────┐
│ 팀 A    │  │ 팀 B    │  │ 팀 C    │
│ 독립    │  │ 독립    │  │ 독립    │
└─────────┘  └─────────┘  └─────────┘
     ↓            ↓            ↓
┌─────────┐  ┌─────────┐  ┌─────────┐
│컴포넌트A│  │컴포넌트B│  │컴포넌트C│
└─────────┘  └─────────┘  └─────────┘

✅ 서로 방해하지 않음
```

### 배포 독립성 (Deployment Independence)

> ✅ **효과**: 결합을 제대로 분리했다면, **운영 중인 시스템에서도** 계층과 유스케이스를 교체 가능

```
운영 중인 시스템
┌─────────────────┐
│  Component A    │ ← 교체 가능 (Hot Swap)
├─────────────────┤
│  Component B    │ ← 교체 가능
├─────────────────┤
│  Component C    │ ← 교체 가능
└─────────────────┘

✅ 전체 시스템 중단 없이 개별 컴포넌트 교체
```

---

## 중복의 종류

### 진짜 중복 (True Duplication)

> ⚠️ **정의**: 한 인스턴스가 변경되면, 동일한 변경을 그 인스턴스의 **모든 복사본에 반드시 적용**해야 한다.

**진짜 중복의 특징:**

```
┌──────────┐     ┌──────────┐
│ 코드 A   │ === │ 코드 A'  │
└──────────┘     └──────────┘
     ↓                ↓
   변경            동일한 변경 필수
```

### 거짓된 (우발적) 중복 (False/Accidental Duplication)

> 💡 **정의**: 중복으로 보이는 두 코드 영역이 **각자의 경로로 발전**한다면, 즉 **서로 다른 속도와 다른 이유로 변경**된다면 진짜 중복이 아니다.

**우발적 중복 예시:**

```
초기 상태 (비슷해 보임)
┌──────────────┐  ┌──────────────┐
│ 화면 구조 A  │  │ 화면 구조 B  │
│ (비슷함)     │  │ (비슷함)     │
└──────────────┘  └──────────────┘
      ↓                  ↓
시간이 지남              시간이 지남
      ↓                  ↓
┌──────────────┐  ┌──────────────┐
│ 화면 구조 A  │  │ 화면 구조 B  │
│ (완전 다름)  │  │ (완전 다름)  │
└──────────────┘  └──────────────┘
```

**주의사항:**

| 상황                      | 판단                    | 조치                      |
| ------------------------- | ----------------------- | ------------------------- |
| **비슷해 보이는 두 화면** | 우발적 중복 가능성 높음 | ❌ 통합하지 말 것         |
| **시간이 지나면**         | 서로 다른 방향으로 분기 | ⚠️ 나중에 분리하느라 고생 |
| **초기 판단이 중요**      | 진짜 중복인지 확인      | ✅ 신중하게 결정          |

**비교 다이어그램:**

```
진짜 중복                우발적 중복
──────────              ─────────────
변경 시 함께 변경         서로 다른 속도로 변경
동일한 이유로 변경        다른 이유로 변경
✅ 통합 권장              ❌ 분리 유지
```

---

## 결합 분리 모드 (Decoupling Modes)

### 3가지 분리 수준

**분리 모드 계층:**

```
┌─────────────────────────────┐
│ 소스 수준 분리 (Source Level)│
│ • 모노리틱 구조              │
│ • 단일 실행 파일             │
│ • 소스 코드 의존성 제어      │
└─────────────────────────────┘
          ↓ 진화
┌─────────────────────────────┐
│배포 수준 분리 (Deployment)   │
│ • JAR, DLL, Gem 등           │
│ • 배포 단위 간 의존성 제어   │
└─────────────────────────────┘
          ↓ 진화
┌─────────────────────────────┐
│서비스 수준 분리 (Service)    │
│ • 마이크로서비스             │
│ • 네트워크 패킷으로만 통신   │
│ • 데이터 구조 수준 의존성    │
└─────────────────────────────┘
```

### 1. 소스 수준 분리 모드

**특징:**

```
┌──────────────────────┐
│   모노리틱 구조       │
├──────────────────────┤
│                      │
│  소스 모듈 A         │
│       ↓              │
│  소스 모듈 B         │
│       ↓              │
│  소스 모듈 C         │
│                      │
└──────────────────────┘
         ↓
  단일 실행 파일 (메모리)
```

**장점:**

- ✅ 소스 코드 모듈 사이의 의존성 제어 가능
- ✅ 간단한 배포 (단일 파일)

### 2. 배포 수준 분리 모드

**특징:**

```
┌─────────┐  ┌─────────┐  ┌─────────┐
│  JAR    │  │  DLL    │  │  Gem    │
│ (모듈A) │  │ (모듈B) │  │ (모듈C) │
└─────────┘  └─────────┘  └─────────┘
     ↓            ↓            ↓
  배포 가능한 단위들 간 의존성 제어
```

**장점:**

- ✅ 배포 단위별 독립적 업데이트
- ✅ 버전 관리 용이

### 3. 서비스 수준 분리 모드

**특징:**

```
┌──────────┐     네트워크     ┌──────────┐
│Service A │ ←──────────→ │Service B │
└──────────┘     패킷      └──────────┘
     ↕                          ↕
네트워크 통신              네트워크 통신
     ↕                          ↕
┌──────────┐                ┌──────────┐
│Service C │                │Service D │
└──────────┘                └──────────┘
```

**장점:**

- ✅ 최소 의존성 (데이터 구조 수준)
- ✅ 완전한 독립성
- ✅ 독립적 배포, 확장, 개발

---

## 아키텍처의 진화 가능성

### 양방향 진화

> 💡 **핵심**: 좋은 아키텍처는 **성장**할 수 있고, 필요시 **되돌릴** 수도 있어야 한다.

**진화 경로 (양방향):**

```
모노리틱 구조
     ↓ (성장)
┌─────────────────┐
│ 단일 파일 배포   │
└─────────────────┘
     ↓ (진화)
┌─────────────────┐
│독립 배포 가능    │
│  단위들의 집합   │
└─────────────────┘
     ↓ (성장)
┌─────────────────┐
│  마이크로서비스  │
│   수준까지 성장  │
└─────────────────┘
     ↑ (필요시 회귀)
  상황이 바뀌면 되돌림
```

**좋은 아키텍처의 유연성:**

```
상황 변화에 따른 대응
─────────────────────

트래픽 증가
    ↓
마이크로서비스로 전환 ✅

트래픽 감소 / 복잡도 증가
    ↓
모노리틱으로 회귀 ✅

✅ 양방향 전환이 쉬워야 함
```

# 17장 - 경계: 선 긋기

## 소프트웨어 아키텍처의 핵심

### 경계(Boundary)란?

> 💡 **핵심**: 소프트웨어 아키텍처는 **선을 긋는 기술**이며, 긋는 선을 **경계(Boundary)**라고 한다.

**아키텍처의 본질:**

```
┌──────────────────────┐
│ 소프트웨어 아키텍처   │
│                      │
│   = 선 긋기 기술      │
│   = 경계 설정        │
└──────────────────────┘
```

---

## 아키텍트의 목표

### 인적 자원 최소화

> 💡 **아키텍트의 목표**: 시스템을 만들고 유지하는 데 드는 **인적 자원을 최소화**하는 것

**결합과 인적 자원의 관계:**

```
❌ 결합 발생
     ↓
┌─────────────────┐
│ 인적 자원 효율  │
│    감소         │
└─────────────────┘
     ↓
개발/유지보수 비용 증가


✅ 경계 명확
     ↓
┌─────────────────┐
│ 인적 자원 효율  │
│    증가         │
└─────────────────┘
     ↓
개발/유지보수 비용 감소
```

---

## 선을 긋는 방법

### 관련 있는 것과 없는 것 분리

> 💡 **원칙**: **관련이 있는 것**과 **없는 것** 사이에 선을 그어라

**경계선이 필요한 곳:**

```
┌──────────────┐
│     GUI      │  ← 사용자 인터페이스
└──────┬───────┘
       │
    ❌ 경계선 (관련 없음)
       │
┌──────┴───────┐
│  업무 규칙    │  ← 핵심 비즈니스 로직
└──────┬───────┘
       │
    ❌ 경계선 (관련 없음)
       │
┌──────┴───────┐
│  Database    │  ← 데이터 저장소
└──────────────┘
```

**3가지 주요 경계:**

| 경계                | 이유                        | 효과                             |
| ------------------- | --------------------------- | -------------------------------- |
| **GUI ↔ 업무 규칙** | GUI는 업무 규칙과 관련 없음 | 화면 변경이 비즈니스에 영향 없음 |
| **DB ↔ GUI**        | DB는 GUI와 관련 없음        | 저장소 변경이 화면에 영향 없음   |
| **DB ↔ 업무 규칙**  | DB는 업무 규칙과 관련 없음  | DB 변경이 비즈니스에 영향 없음   |

### 경계선 시각화

**컴포넌트 간 분리:**

```
┌─────────────────────────┐
│      Presentation       │
│         (GUI)           │
└────────────┬────────────┘
             │
        ═════════════  ← 경계선 1
             │
┌────────────┴────────────┐
│    Business Logic       │
│     (업무 규칙)          │
└────────────┬────────────┘
             │
        ═════════════  ← 경계선 2
             │
┌────────────┴────────────┐
│    Data Persistence     │
│      (Database)         │
└─────────────────────────┘
```

---

## 플러그인 아키텍처

### 플러그인의 역사

> 💡 **소프트웨어 개발 기술의 역사**: 플러그인을 쉽게 생성하여, **확장 가능**하며 **유지보수가 쉬운** 시스템 아키텍처를 확립할 수 있게 만드는 방법에 대한 이야기

**플러그인 아키텍처의 목표:**

```
┌──────────────────┐
│ 플러그인 아키텍처 │
├──────────────────┤
│ ✅ 쉬운 생성      │
│ ✅ 확장 가능     │
│ ✅ 유지보수 용이  │
└──────────────────┘
```

### 플러그인 구조

**핵심과 플러그인:**

```
        ┌──────────┐
        │ Plugin A │
        │  (GUI)   │
        └────┬─────┘
             │
             ↓
    ┌────────────────┐
    │   Core         │  ← 핵심 업무 규칙
    │ (Business)     │
    └────────────────┘
             ↑
             │
        ┌────┴─────┐
        │ Plugin B │
        │   (DB)   │
        └──────────┘
```

---

## 컴포넌트 분할 전략

### 경계선을 그리는 과정

> 💡 **핵심 과정**: 시스템을 **컴포넌트 단위로 분할**하고, **의존성 방향을 제어**한다.

**분할 과정:**

```
1단계: 컴포넌트 분할
─────────────────────
┌─────────────────────────┐
│      전체 시스템         │
└─────────────────────────┘
          ↓
┌──────┐ ┌──────┐ ┌──────┐
│ GUI  │ │ 핵심 │ │  DB  │
└──────┘ └──────┘ └──────┘

2단계: 컴포넌트 분류
─────────────────────
핵심 업무 규칙 컴포넌트
  ↑
  • 비즈니스 로직
  • 도메인 규칙

플러그인 컴포넌트
  ↑
  • 핵심 업무와 직접 관련 없음
  • 필수 기능 포함 (UI, DB 등)

3단계: 의존성 방향 설정
─────────────────────
모든 화살표가 핵심 업무를 향하도록
```

**컴포넌트 분류:**

| 컴포넌트 유형      | 역할                        | 예시                 |
| ------------------ | --------------------------- | -------------------- |
| **핵심 업무 규칙** | 비즈니스 로직, 도메인 규칙  | 주문 처리, 결제 로직 |
| **플러그인**       | 필수 기능이지만 핵심과 무관 | GUI, Database, API   |

### 의존성 방향 제어

**올바른 의존성 방향:**

```
┌──────────┐
│   GUI    │
│(Plugin)  │
└────┬─────┘
     │
     ↓ 의존
┌────┴──────┐
│   Core    │  ← 핵심 (의존받음)
│ Business  │
└────┬──────┘
     ↑ 의존
     │
┌────┴─────┐
│    DB    │
│(Plugin)  │
└──────────┘
```

**잘못된 의존성 방향:**

```
❌ 핵심이 플러그인에 의존

┌──────────┐
│   Core   │
│ Business │
└────┬─────┘
     ↓
┌────┴─────┐
│    DB    │  ← 핵심이 DB에 의존 (잘못됨!)
└──────────┘
```

---

## 적용 원칙

### DIP와 SAP의 응용

> 💡 **원칙 적용**: 의존성 역전 원칙(DIP)과 안정된 추상화 원칙(SAP)을 응용

**DIP (의존성 역전 원칙) 적용:**

```
구체적인 것 → 추상적인 것 의존

┌──────────┐
│   GUI    │
│(구체)    │
└────┬─────┘
     │
     ↓ 인터페이스를 통해 의존
┌────┴──────────┐
│   Interface   │
└───────────────┘
        ↑
        │ 구현
┌───────┴───────┐
│  Business     │
│  (추상/안정)  │
└───────────────┘
```

**SAP (안정된 추상화 원칙) 적용:**

```
불안정(변경 많음)     안정(변경 적음)
       ↓                  ↓
┌──────────┐        ┌──────────┐
│   GUI    │   →    │ Business │
│ (구체적)  │        │ (추상적)  │
└──────────┘        └──────────┘
```

**원칙 적용 효과:**

| 원칙    | 적용 방법           | 효과                                   |
| ------- | ------------------- | -------------------------------------- |
| **DIP** | 추상에 의존         | 구체적인 구현 변경 시 핵심에 영향 없음 |
| **SAP** | 안정적일수록 추상적 | 변경이 적은 핵심은 추상적으로 유지     |

---

## 경계선 긋기의 이점

### 변경의 격리

**경계선이 있을 때:**

```
✅ GUI 변경
┌──────────┐
│   GUI    │  ← 변경됨
└────┬─────┘
     │
  ════════  ← 경계선 (변경 차단)
     │
┌────┴──────┐
│ Business  │  ← 영향 없음 ✅
└────┬──────┘
     │
  ════════
     │
┌────┴─────┐
│    DB    │  ← 영향 없음 ✅
└──────────┘
```

**경계선이 없을 때:**

```
❌ GUI 변경
┌──────────┐
│   GUI    │  ← 변경됨
└────┬─────┘
     │
┌────┴──────┐
│ Business  │  ← 영향 받음 ❌
└────┬──────┘
     │
┌────┴─────┐
│    DB    │  ← 영향 받음 ❌
└──────────┘
```

### 독립적 개발과 배포

**경계선의 효과:**

```
┌─────────────────────────┐
│  경계선 설정의 효과      │
├─────────────────────────┤
│                         │
│ ① 독립적 개발            │
│   • 팀 간 간섭 최소화    │
│   • 병렬 작업 가능       │
│                         │
│ ② 독립적 배포            │
│   • 부분 업데이트 가능   │
│   • 위험 최소화          │
│                         │
│ ③ 테스트 용이성          │
│   • 컴포넌트별 테스트    │
│   • Mock 객체 활용       │
│                         │
│ ④ 인적 자원 효율 증가    │
│   • 변경 영향 최소화     │
│   • 유지보수 비용 감소   │
│                         │
└─────────────────────────┘
```
