# 아키텍처 경계 (Architectural Boundaries)

## 15장 - 아키텍처란?

### 아키텍처의 정의

> 소프트웨어 아키텍처는 시스템을 구축했던 사람들이 만들어낸 **시스템의 형태**

**아키텍처를 결정하는 3가지 요소:**

1. 시스템을 컴포넌트로 분할하는 방법
2. 분할된 컴포넌트를 배치하는 방법
3. 컴포넌트가 서로 의사소통하는 방식

### 아키텍처의 목표

- **시스템 수명과 관련된 비용 최소화**
- **프로그래머 생산성 최대화**

### 정책과 세부사항의 분리

> 아키텍처의 핵심: **정책(Policy)과 세부사항(Details)을 분리**

```
┌─────────────────┐
│     정책        │  ← 비즈니스 규칙, 핵심 로직
│  (Policy)       │
└────────┬────────┘
         │
         │ ❌ 의존하지 않음
         │
         ↓
┌─────────────────┐
│   세부사항       │  ← DB, UI, 프레임워크
│  (Details)      │
└─────────────────┘
```

- **정책**: 비즈니스 규칙과 도메인 로직
- **세부사항**: 데이터베이스, UI, 프레임워크

**좋은 아키텍트의 전략:**

- 세부사항에 대한 결정을 가능한 한 오래 미룸
- 더 많은 실험과 시도가 가능해짐
- 충분한 정보를 얻은 후 최선의 선택 가능

---

## 16장 - 독립성

### 좋은 아키텍처가 지원하는 것

1. **유스케이스 (Use Case)** - 시스템의 의도가 명확
2. **운영 (Operation)** - 처리량과 응답 시간 보장
3. **개발 (Development)** - 독립적인 팀 개발 지원
4. **배포 (Deployment)** - 즉각 배포 가능

### 독립성의 종류

**개발 독립성:**

```
┌─────────┐  ┌─────────┐  ┌─────────┐
│ 팀 A    │  │ 팀 B    │  │ 팀 C    │
│ 독립    │  │ 독립    │  │ 독립    │
└─────────┘  └─────────┘  └─────────┘
     ↓            ↓            ↓
┌─────────┐  ┌─────────┐  ┌─────────┐
│컴포넌트A│  │컴포넌트B│  │컴포넌트C│
└─────────┘  └─────────┘  └─────────┘

✅ 서로 방해하지 않음
```

**배포 독립성:**

- 운영 중인 시스템에서도 컴포넌트 교체 가능
- 전체 시스템 중단 없이 개별 업데이트 가능

### 결합 분리 모드

**3가지 분리 수준:**

```
┌────────────────────────────┐
│ 1. 소스 수준 분리           │
│    • 모노리틱 구조          │
│    • 단일 실행 파일         │
└────────────────────────────┘
          ↓ 진화
┌────────────────────────────┐
│ 2. 배포 수준 분리           │
│    • JAR, DLL 등           │
│    • 독립적 배포 가능       │
└────────────────────────────┘
          ↓ 진화
┌────────────────────────────┐
│ 3. 서비스 수준 분리         │
│    • 마이크로서비스         │
│    • 네트워크 통신          │
└────────────────────────────┘
```

> 좋은 아키텍처는 **성장**할 수 있고, 필요시 **되돌릴** 수도 있어야 한다.

---

## 17장 - 경계: 선 긋기

### 경계(Boundary)란?

> 소프트웨어 아키텍처는 **선을 긋는 기술**이며, 긋는 선을 **경계(Boundary)**라고 한다.

### 경계선을 긋는 원칙

> **관련이 있는 것**과 **없는 것** 사이에 선을 그어라

**주요 경계선:**

```
┌──────────────┐
│     GUI      │  ← 사용자 인터페이스
└──────┬───────┘
       │
    ════════  ← 경계선 1
       │
┌──────┴───────┐
│  업무 규칙    │  ← 핵심 비즈니스 로직
└──────┬───────┘
       │
    ════════  ← 경계선 2
       │
┌──────┴───────┐
│  Database    │  ← 데이터 저장소
└──────────────┘
```

**경계가 필요한 이유:**

- GUI는 업무 규칙과 관련 없음
- Database는 업무 규칙과 관련 없음
- 각 요소는 독립적으로 변경 가능해야 함

### 업무 규칙의 예시

은행 시스템의 경우:

- "계좌 잔액이 출금 금액보다 적으면 출금할 수 없다"
- "모든 거래는 트랜잭션 로그에 기록되어야 한다"
- "이자는 매일 자정에 계산되어 누적된다"

→ 이러한 규칙은 GUI, API, 콘솔 등 **어떤 인터페이스에서든 동일하게 작동**해야 함

---

## 플러그인 아키텍처

### 컴포넌트 분류

**핵심 업무 규칙:**

- 비즈니스 로직
- 도메인 규칙
- 시스템의 핵심 가치

**플러그인 컴포넌트:**

- 필수 기능이지만 핵심과 무관
- 대체 가능한 요소들
- 예: React, Database, ORM

```
        ┌──────────┐
        │ Plugin A │
        │  (GUI)   │
        └────┬─────┘
             │
             ↓
    ┌────────────────┐
    │   Core         │  ← 핵심 업무 규칙
    │ (Business)     │
    └────────────────┘
             ↑
             │
        ┌────┴─────┐
        │ Plugin B │
        │   (DB)   │
        └──────────┘
```

### 의존성 방향

**올바른 의존성:**

```
┌──────────┐
│   GUI    │
│(Plugin)  │
└────┬─────┘
     │
     ↓ 의존
┌────┴──────┐
│   Core    │  ← 핵심 (의존받음)
│ Business  │
└────┬──────┘
     ↑ 의존
     │
┌────┴─────┐
│    DB    │
│(Plugin)  │
└──────────┘
```

**핵심 원칙:**

- 모든 화살표가 핵심 업무를 향해야 함
- 핵심 업무는 플러그인에 의존하지 않음
- DIP(의존성 역전 원칙) 적용

---

## 경계선의 효과

### 변경의 격리

```
✅ GUI 변경
┌──────────┐
│   GUI    │  ← 변경됨
└────┬─────┘
     │
  ════════  ← 경계선 (변경 차단)
     │
┌────┴──────┐
│ Business  │  ← 영향 없음 ✅
└────┬──────┘
     │
  ════════
     │
┌────┴─────┐
│    DB    │  ← 영향 없음 ✅
└──────────┘
```

### 경계선 설정의 장점

1. **독립적 개발** - 팀 간 간섭 최소화, 병렬 작업 가능
2. **독립적 배포** - 부분 업데이트 가능, 위험 최소화
3. **테스트 용이성** - 컴포넌트별 테스트, Mock 객체 활용
4. **인적 자원 효율 증가** - 변경 영향 최소화, 유지보수 비용 감소

---

## 핵심 요약

**아키텍처 경계의 본질:**

1. 정책(Policy)과 세부사항(Details)을 분리
2. 관련 있는 것과 없는 것 사이에 선을 긋기
3. 의존성 방향을 핵심 업무 쪽으로 향하게 하기
4. 플러그인 아키텍처로 변경에 유연하게 대응

**좋은 아키텍처의 특징:**

- 세부사항 결정을 최대한 지연
- 독립적 개발과 배포 가능
- 변경의 영향을 격리
- 시스템의 성장과 축소에 유연
